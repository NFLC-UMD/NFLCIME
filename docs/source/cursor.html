<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Cursor'>/**
</span> * @docauthor Steve Drucker &lt;sdrucker@figleaf.com&gt;
 *
 * @class Cursor
 *
 * Character insertion functions and text selection handling
 *
 * Critical functions: {@link #onCursorInsertHTML}
 */

NFLCIME.dispatchEvent({
	type : &#39;ModuleAdd&#39;,
	module : {
		id : &#39;cursor&#39;,
		type : &#39;core&#39;,

<span id='Cursor-method-onModuleActivate'>		/**
</span>		 * Attach DOM event Listeners
		 *
		 * @param {Object} [evt] Event details
		 */

		onModuleActivate : function(evt) {
			var module = evt.module;
			if (module == this &amp;&amp; !this.active) {
				this.active = true;
				// get list of windows for which IME is already activated and
				// attach DOM handlers to them
				var list = [];
				NFLCIME.dispatchEvent({
							type : &#39;WindowGetList&#39;,
							list : list
						});
				for (var i = 0; i &lt; list.length; i++) {
					var win = list[i];
					this.attachDOMHandlers(win);
				}
			
<span id='Cursor-event-WindowListen'>				/**
</span>				 * @event WindowListen
				 * Listen for new windows
				 */
				NFLCIME.addEventListener(&#39;WindowListen&#39;, this);

<span id='Cursor-event-WindowIgnore'>				/**
</span>				 * @event WindowIgnore
				 *
				 */
				NFLCIME.addEventListener(&#39;WindowIgnore&#39;, this);

<span id='Cursor-event-CursorMove'>				/**
</span>				 * @event CursorMove
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorMove&#39;, this);

<span id='Cursor-event-CursorGetContext'>				/**
</span>				 * @event CursorGetContext
				 *
				 */

				NFLCIME.addEventListener(&#39;CursorGetContext&#39;, this);

<span id='Cursor-event-CursorGetFocusedEdit'>				/**
</span>				 * @event CursorGetFocusedEdit
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorGetFocusedEdit&#39;, this);

<span id='Cursor-event-CursorSaveFocusedEdit'>				/**
</span>				 * @event CursorSaveFocusedEdit
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorSaveFocusedEdit&#39;, this);

<span id='Cursor-event-CursorRestoreFocusedEdit'>				/**
</span>				 * @event CursorRestoreFocusedEdit
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorRestoreFocusedEdit&#39;, this);

<span id='Cursor-event-CursorGetContainer'>				/**
</span>				 * @event CursorGetContainer
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorGetContainer&#39;, this);

<span id='Cursor-event-CursorGetSelectedText'>				/**
</span>				 * @event CursorGetSelectedText
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorGetSelectedText&#39;, this);

<span id='Cursor-event-CursorInsertText'>				/**
</span>				 * @event CursorInsertText
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorInsertText&#39;, this);

<span id='Cursor-event-CursorInsertHTML'>				/**
</span>				 * @event CursorInsertHTML
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorInsertHTML&#39;, this);

<span id='Cursor-event-CursorClearSelection'>				/**
</span>				 * @event CursorClearSelection
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorClearSelection&#39;, this);

<span id='Cursor-event-CursorInsertEmptyText'>				/**
</span>				 * @event CursorInsertEmptyText
				 *
				 */
				NFLCIME.addEventListener(&#39;CursorInsertEmptyText&#39;, this);
			}
		},

<span id='Cursor-method-onModuleDeactivate'>		/**
</span>		 * Remove event listeners
		 *
		 * @param {Object} [evt] Event details
		 */

		onModuleDeactivate : function(evt) {
			var module = evt.module;
			if (module == this &amp;&amp; this.active) {
				this.active = false;
				var list = [];
				NFLCIME.dispatchEvent({
							type : &#39;WindowGetList&#39;,
							list : list
						});
				for (var i = 0; i &lt; list.length; i++) {
					var win = list[i];
					this.detachDOMHandlers(win);
				}
				NFLCIME.removeEventListener(&#39;WindowListen&#39;, this);
				NFLCIME.removeEventListener(&#39;WindowIgnore&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorMove&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorGetContext&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorGetFocusedEdit&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorSaveFocusedEdit&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorRestoreFocusedEdit&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorGetContainer&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorGetSelectedText&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorInsertText&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorInsertHTML&#39;, this);
				NFLCIME.removeEventListener(&#39;CursorClearSelection&#39;, this);
			}
		},
		


<span id='Cursor-method-onCursorMove'>		/**
</span>		 * Figures out the start and end of the cursor text selection and moves it to the &quot;dropped&quot; location
		 * If dragging within a wysiwyg editor, it invokes the {@link #moveRangeEnd}
		 * and {@link #moveRangeStart} methods
		 * @param {Object} [evt] Event details
		 */


		onCursorMove : function(evt) {
			var edit = evt.target;
			var move_end = evt.end;
			var move_start = evt.start;
			var doc = edit.ownerDocument;
			switch (this.browser) {
				case &#39;ie&#39; :
					// TODO: check to ensure the new selection doesn&#39;t end up
					// outside the edit box
					var range = doc.selection.createRange();
					// move the end point first if it&#39;s being moved forward, so
					// the starting point won&#39;t end up moving past it
					if (move_end &gt; 0) {
						if (move_end != 0) {
							range.moveEnd(&#39;character&#39;, move_end);
						}
						if (move_start != 0) {
							range.moveStart(&#39;character&#39;, move_start);
						}
					} else {
						if (move_start != 0) {
							range.moveStart(&#39;character&#39;, move_start);
						}
						if (move_end != 0) {
							range.moveEnd(&#39;character&#39;, move_end);
						}
					}
					range.select();
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						if (move_end &gt; 0) {
							edit.selectionEnd += move_end;
							edit.selectionStart += move_start;
						} else {
							edit.selectionStart += move_start;
							edit.selectionEnd += move_end;
						}
					} else {
						var win = doc.defaultView;
						try {
							var selection = win.getSelection();
							var range = selection.getRangeAt(0);
							if (move_end &gt; 0) {
								this.moveRangeEnd(edit, range, move_end);
								this.moveRangeStart(edit, range, move_start);
							} else {
								this.moveRangeStart(edit, range, move_start);
								this.moveRangeEnd(edit, range, move_end);
							}
							// need to do this for safari as modifying the range
							// alone doesn&#39;t change the selection
							if (this.browser == &#39;safari&#39;) {
								var new_range = range.cloneRange();
								selection.removeAllRanges();
								selection.addRange(new_range);
							}
						} catch (e) {
							if(window.console) console.log(e);
						}
					}
					break;
			}
			if (edit == this.focusedEdit) {
				this.previousCursorPosition = this.getCursorPosition(edit);
			}
		},

<span id='Cursor-method-onCursorSaveFocusedEdit'>		/**
</span>		 * Stores previous event target into the {@link #previousFocusedEdit} runtime property
		 * @param {Object} [evt] Event details
		 */

		onCursorSaveFocusedEdit : function(evt) {
			var edit = evt.target;
			this.previousFocusedEdit = edit;
		},

<span id='Cursor-method-onCursorRestoreFocusedEdit'>		/**
</span>		 * If {@link #previousFocusedEdit} is set, restores cursor and element focus to previous event target
		 * @param {Object} [evt] Event details
		 */

		onCursorRestoreFocusedEdit : function(evt) {
			if (this.previousFocusedEdit) {
				var edit = this.previousFocusedEdit;
				var doc = edit.ownerDocument;
				var win = (doc.parentWindow)
						? doc.parentWindow
						: doc.defaultView;
				win.focus();
				edit.focus();
				evt.target = this.previousFocusedEdit;
			}
		},


<span id='Cursor-method-onCursorGetContainer'>		/**
</span>		 * Figures out which editable object (textarea, input, or editable window) that the cursor is in and
		 * assigns it to the evt.container property
		 *
		 * @param {Object} [evt] Event details
		 */

		onCursorGetContainer : function(evt) {
			var edit = evt.target;
			switch (this.browser) {
				case &#39;ie&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						evt.container = edit;
					} else {
						var range = document.selection.createRange();
						evt.container = range.parentElement();
					}
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						evt.container = edit;
					} else {
						var doc = edit.ownerDocument;
						var win = doc.defaultView;
						try {
							var selection = win.getSelection();
							if (selection.rangeCount &gt; 0) {
								var range = selection.getRangeAt(0);
								var container = range.commonAncestorContainer;
								evt.container = (container.nodeType == 1)
										? container
										: container.parentNode;
							}
						} catch (e) {
							if(window.console) console.log(e);
						}
					}
					break;
			}
		},
		

<span id='Cursor-method-onCursorGetContext'>		/**
</span>		 * Get a certain number of character before and after the selection.
		 * Sets evt.textBehind string and event.textAhead string
		 *
		 * @param {Object} [evt] Event details
		 * @param {Number} [evt.behindCount] Number of chars before cursor
		 * @param {Number} [evt.aheadCount] Number of chars after cursor
		 */

		onCursorGetContext : function(evt) {
			var edit = evt.target;
			var behind_count = evt.behindCount;
			var ahead_count = evt.aheadCount;
			evt.textBehind = &#39;&#39;;
			evt.textAhead = &#39;&#39;;
			switch (this.browser) {
				case &#39;ie&#39; :
					var range = document.selection.createRange();
					var edit_parent = edit.parentNode;
					range = range.duplicate();
					var bookmark = range.getBookmark();
					range.collapse(true);
					for (var i = 0, outside = false; !outside
							&amp;&amp; i &lt; behind_count; i++) {
						range.moveStart(&#39;character&#39;, -1);
						outside = true;
						for (var p = range.parentElement(); p; p = p.parentNode) {
							if (p == edit) {
								evt.textBehind = range.text;
								outside = false;
								break;
							}
						}
					}
					range.moveToBookmark(bookmark);
					range.collapse(false);
					for (var i = 0, outside = false; !outside
							&amp;&amp; i &lt; ahead_count; i++) {
						range.moveEnd(&#39;character&#39;, +1);
						outside = true;
						for (var p = range.parentElement(); p; p = p.parentNode) {
							if (p == edit) {
								evt.textAhead = range.text;
								outside = false;
								break;
							}
						}
					}
					range.moveToBookmark(bookmark);
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						var value = edit.value;
						var behind_end = edit.selectionStart;
						var behind_start = Math.max(0, edit.selectionStart
										- behind_count);
						var ahead_start = edit.selectionEnd;
						var ahead_end = Math.min(value.length,
								edit.selectionEnd + ahead_count);
						evt.textAhead = value.substring(ahead_start, ahead_end);
						evt.textBehind = value.substring(behind_start,
								behind_end);
					} else {
						var doc = edit.ownerDocument;
						var win = doc.defaultView;
						try {
							var selection = win.getSelection();
							var range = selection.getRangeAt(0);
							var text = range.toString();
							var behind_range = range.cloneRange();
							behind_range.collapse(true);
							this.moveRangeStart(edit, behind_range,
									-behind_count);
							evt.textBehind = behind_range.toString();
							var ahead_range = range.cloneRange();
							ahead_range.collapse(true);
							this.moveRangeStart(edit, ahead_range,
									text.length);
							this.moveRangeEnd(edit, ahead_range, +ahead_count);
							evt.textAhead = ahead_range.toString();
						} catch (e) {
							if(window.console) console.log(e);
						}
					}
					break;
			}
		},


<span id='Cursor-method-onCursorGetFocusedEdit'>		/**
</span>		 * Returns {@link #focusedEdit} as evt.target if {@link #focusedEdit} is defined and {@link #windowLostFocused} is false
		 *
		 * @param {Object} [evt] Event details
		 * @param {Number} [evt.behindCount] Number of chars before cursor
		 * @param {Number} [evt.aheadCount] Number of chars after cursor
		 */


		onCursorGetFocusedEdit : function(evt) {
			if (this.focusedEdit &amp;&amp; !this.windowLostFocus) {
				evt.target = this.focusedEdit;
			}
		},
		

<span id='Cursor-method-onCursorInsertText'>		/**
</span>		 * Insert text at the cursor, removing any selected text
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] HTML Element
		 * @param {String} [evt.text] Text to insert
		 */

		onCursorInsertText : function(evt) {
			var edit = evt.target;
			var text = evt.text;
			var doc = edit.ownerDocument;
			switch (this.browser) {
				case &#39;ie&#39; :
					// TODO: check to see if the range is in the edit
					var range = doc.selection.createRange();
					if (range.text.length &gt; 0) {
						doc.selection.clear();
					}
					if (text) {
						range.text = text;
						range.collapse(false);
						range.scrollIntoView();
					}
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						if (this.browser == &#39;firefox&#39;) {
							if (text) {
								// change
								text = text.replace(/([^\u000a]|^)\u000d/,
										&#39;$1\u000a&#39;);
								for (var i = 0; i &lt; text.length; i++) {
									var c = text.charCodeAt(i);
									var evt = doc.createEvent(&#39;KeyEvents&#39;);
									evt.initKeyEvent(&#39;keypress&#39;, true, true,
											win, false, false, false, false, 0,
											c);
									edit.dispatchEvent(evt);
								}
							} else {
								// delete the selection
								if (edit.selectionStart != edit.selectionEnd) {
									var evt = doc.createEvent(&#39;KeyEvents&#39;);
									evt.initKeyEvent(&#39;keypress&#39;, true, true,
											win, false, false, false, false,
											0x08, 0);
									edit.dispatchEvent(evt);
								}
							}
						} else {
							var value = edit.value;
							var beginning = value
									.substr(0, edit.selectionStart)
									+ text;
							var end = value.substr(edit.selectionEnd);
							edit.value = beginning;
							edit.scrollTop = edit.scrollHeight;
							edit.scrollLeft = edit.scrollWidth;
							edit.value = beginning + end;
							edit.setSelectionRange(beginning.length,
									beginning.length);
						}
					} else {
						var win = doc.defaultView;

						var selection = win.getSelection();
						var range = selection.getRangeAt(0);
						if (range.toString().length &gt; 0) {
							range.deleteContents();
						}
						if (text) {
							var text_node = doc.createTextNode(text);
							range.insertNode(text_node);
							// now we need to normalize the text node so complex
							// text will join correctly
							// first, figure out where the selection will be
							// after the normalization
							var cursor = this.findNormalizedPosition(text_node,
									text.length);
							// normalize the parent node
							var parent = text_node.parentNode;
							parent.normalize();
							// restore the cursor
							var normalized_node = parent.childNodes[cursor.nodeIndex];
							range.selectNode(normalized_node);
							range.setStart(normalized_node, cursor.textIndex);
							range.setEnd(normalized_node, cursor.textIndex);
							selection.removeAllRanges();
							selection.addRange(range);
						}
						// scroll the container if the caret isn&#39;t visible,
						// inserting a span so we know where it is
						var caret = doc.createElement(&#39;SPAN&#39;);
						caret.textContent = &#39;\u200d&#39;; // ZWJ
						range.insertNode(caret);
						var top = caret.offsetTop, bottom = top
								+ caret.offsetHeight;
						var left = caret.offsetLeft, right = left
								+ caret.offsetWidth;
						for (view = caret.offsetParent; view
								&amp;&amp; view.nodeType == 1; view = view.parentNode) {
							var view_top = view.scrollTop, view_bottom = view_top
									+ view.clientHeight;
							var view_left = view.scrollLeft, view_right = view_left
									+ view.clientWidth;
							if (view == doc.body) {
								var html = view.parentNode;
								view_bottom = view_top + html.clientHeight;
								view_right = view_left + html.clientWidth;
							}
							if (top &lt; view_top) {
								view.scrollTop += top - view_top;
							} else if (bottom &gt; view_bottom) {
								view.scrollTop += bottom - view_bottom;
							}
							if (left &lt; view_left) {
								view.scrollLeft += left - view_left;
							} else if (right &gt; view_right) {
								view.scrollLeft += right - view_right;
							}
							var delta_x = view.offsetLeft - view.scrollLeft;
							var delta_y = view.offsetTop - view.scrollTop;
							top += delta_x;
							left += delta_y;
						}
						// rejoin text node that&#39;s been been cut into two
						var caret_parent = caret.parentNode;
						var prev = caret.previousSibling, next = caret.nextSibling;
						if (prev &amp;&amp; next &amp;&amp; prev.nodeType == 3
								&amp;&amp; next.nodeType == 3) {
							var cursor = this.findNormalizedPosition(prev,
									prev.nodeValue.length);
							caret_parent.normalize();
							var normalized_node = caret_parent.childNodes[cursor.nodeIndex];
							range.selectNode(normalized_node);
							range.setStart(normalized_node, cursor.textIndex);
							range.setEnd(normalized_node, cursor.textIndex);
							selection.removeAllRanges();
							selection.addRange(range);
						}
						caret_parent.removeChild(caret);
					}
					break;
			}
			if (edit == this.focusedEdit) {
				this.previousCursorPosition = this.getCursorPosition(edit);
			}
		},
		
<span id='Cursor-method-onCursorInsertHTML'>		/**
</span>		 * Insert HTML at the current cursor position
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] HTML Element
		 * @param {String} [evt.html] HTML to insert
		 * @param {String} [evt.text] Plain text to insert
		 */


		onCursorInsertHTML : function(evt) {
			var edit = evt.target;
			var html = evt.html;
			var plain_text = evt.text;
			var doc = edit.ownerDocument;
			if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
				this.onCursorInsertText(evt);
			} else {
				switch (this.browser) {
					case &#39;ie&#39; :
						// TODO: check to see if the range is in the edit
						var range = doc.selection.createRange();
						if (range.text.length &gt; 0) {
							doc.selection.clear();
						}
						range.pasteHTML(html);
						range.collapse(false);
						range.scrollIntoView();
						break;
					case &#39;firefox&#39; :
					case &#39;safari&#39; :
						var win = doc.defaultView;
						var selection = win.getSelection();
						var range = selection.getRangeAt(0);
						var fragment = range.createContextualFragment(html);
						var last = fragment.lastChild;
						var parNode = range.startContainer.parentNode;
						
						range.deleteContents();
						
						if(parNode.getAttribute(&#39;lang&#39;)){
							var langRange = document.createRange();
							langRange.setStartAfter(parNode);
							langRange.insertNode(fragment)
						}else{
							range.insertNode(fragment);
						}
						
						// set cursor to behind last item
						if (last) {
							selection.collapse(last, (last.nodeType == 3)
											? last.nodeValue.length
											: 1);
							var element = (last.nodeType == 3)
									? last.parentNode
									: last;
							element.scrollIntoView(false);
						}
						break;
				}
			}
			if (edit == this.focusedEdit) {
				this.previousCursorPosition = this.getCursorPosition(edit);
			}
		},


<span id='Cursor-method-onCursorInsertTag'>		/**
</span>		 * Insert HTML element at cursor position, deleting current selection
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] HTML Element
		 * @param {String} [evt.html] HTML to insert
		 */


		onCursorInsertTag : function(evt) {
			var edit = evt.target;
			var tag = evt.html;
			var doc = edit.ownerDocument;
			if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
			} else {
				switch (this.browser) {
					case &#39;ie&#39; :
						// TODO: check to see if the range is in the edit
						var range = doc.selection.createRange();
						if (range.text.length &gt; 0) {
							doc.selection.clear();
						}
						range.pasteHTML(tag);
						range.collapse(true);
						range.scrollIntoView();
						break;
					case &#39;firefox&#39; :
					case &#39;safari&#39; :
						var win = doc.defaultView;
						var selection = win.getSelection();
						var range = selection.getRangeAt(0);
						range.deleteContents();
						var fragment = range.createContextualFragment(tag);
						var last = fragment.lastChild;
						range.insertNode(fragment);
						// set cursor to within last item
						if (last) {
							range.setStart(last, 0);
							range.setEnd(last, 0);
							selection.removeAllRanges();
							selection.addRange(range);
							var element = (last.nodeType == 3)
									? last.parentNode
									: last;
							element.scrollIntoView(false);
						}
						break;
				}
			}
			if (edit == this.focusedEdit) {
				// this.previousCursorPosition = this.getCursorPosition(edit);
			}
		},


<span id='Cursor-method-onCursorInsertEmptyText'>		/**
</span>		 * Insert text node containing character &#39;\ufeff&#39; at cursor position.
		 * This is the Unicode Character &#39;ZERO WIDTH NO-BREAK SPACE&#39; and is used to set the Byte Order Mark
		 * See http://en.wikipedia.org/wiki/Byte_order_mark for more details.
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] HTML Element
		 */

		onCursorInsertEmptyText : function(evt){
			var doc = evt.target,
			    selection = doc.getSelection(),
			    range =  selection.getRangeAt(0),
			    par_selection_node = range.commonAncestorContainer.parentNode,
			    insertAfter = function h(a, d) {
				var b = d.nextSibling,
				    f = d.parentNode;
				
				b ? f.insertBefore(a, b) : f.appendChild(a);
				return a
			    },
			    text_Node = doc.createTextNode(&#39;\ufeff&#39;),
			    text_Node = insertAfter(text_Node, par_selection_node);
			    
			    range.setStartAfter(text_Node);
			    selection.removeAllRanges();
			    selection.addRange(range);	
		},


<span id='Cursor-method-onCursorGetSelectedText'>		/**
</span>		 * Sets the evt.text property by getting the currently selected text
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] HTML Element
		 * @param {Object} [evt.text] HTML Element
		 */

		onCursorGetSelectedText : function(evt) {
			var edit = evt.target;
			var text = evt.text;
			var doc = edit.ownerDocument;
			switch (this.browser) {
				case &#39;ie&#39; :
					var range = doc.selection.createRange();
					evt.text = range.text;
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						evt.text = edit.value.substring(edit.selectionStart,
								edit.selectionEnd);
					} else {
						var win = doc.defaultView;
						if (win) {
							var selection = win.getSelection();
							if (selection.rangeCount &gt; 0) {
								var range = selection.getRangeAt(0);
								evt.text = range.toString();
							} else {
								evt.text = &#39;&#39;;
							}
						}
					}
					break;
			}
		},
		

<span id='Cursor-method-onCursorClearSelection'>		/**
</span>		 * Clear the current text selection
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] HTML Element
		 */

		onCursorClearSelection : function(evt) {
			var edit = evt.target;
			var doc = edit.ownerDocument;
			switch (this.browser) {
				case &#39;ie&#39; :
					var range = doc.selection.createRange();
					var parent = range.parentElement();
					if (range.text.length &gt; 0) {
						doc.selection.clear();
					}
					range.collapse(false);
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					if (edit.tagName == &#39;TEXTAREA&#39; || edit.tagName == &#39;INPUT&#39;) {
						var sel_start = edit.selectionStart, sel_end = edit.selectionEnd;
						edit.value = edit.value.substr(0, sel_start)
								+ edit.value.substr(sel_end);
						edit.selectionEnd = sel_start;
					} else {
						var win = doc.defaultView;
						var selection = win.getSelection();
						var range = selection.getRangeAt(0);
						range.deleteContents();
					}
			}
		},
		

<span id='Cursor-method-fireElementChangeEvent'>		/**
</span>		 * Fire an onchange event after element blur
		 *
		 */

		fireElementChangeEvent : function() {
			var element;
			if (this.focusedEdit) {
				element = this.focusedEdit;
			} else {
				element = this.previousFocusedEdit;
			}
			if (element) {
				var doc = element.ownerDocument;
				var changeEvent;
				if (doc.createEventObject) { // IE
					changeEvent = doc.createEventObject();
					element.fireEvent(&#39;onchange&#39;, changeEvent);
				} else {
					changeEvent = doc.createEvent(&#39;HTMLEvents&#39;);
					changeEvent.initEvent(&#39;change&#39;, true, true);
					element.dispatchEvent(changeEvent);
				}
			}
		},
		

<span id='Cursor-method-onElementFocus'>		/**
</span>		 *  Keep track of which edit control has focus
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] Element firing the event
		 */


		onElementFocus : function(evt) {
			var element = evt.target;
	
			if (element &amp;&amp; element.nodeType == 9) {
				element = element.body;
			}
			if (element &amp;&amp; element.tagName == &#39;HTML&#39;) {
				element = element.ownerDocument.body;
			}
			if (!element || element.tagName != &#39;IFRAME&#39;) {
				if (this.focusedEdit != element) {
					
					var prev = this.focusedEdit;
					if (!this.isEditControl(element)) {
						element = null;
					}
					
					this.focusedEdit = element;
			
					NFLCIME.dispatchEvent({
								type : &#39;FocusChanged&#39;,
								target : this.focusedEdit,
								previousTarget : prev
							});
					if (this.focusedEdit) {
						this.previousCursorPosition = this
								.getCursorPosition(this.focusedEdit);
						this.scheduleCursorCheck(true);
					} else {
						this.stopCursorCheck();
					}
				}
				if (this.onElementBlurTimeoutId) {
					clearTimeout(this.onElementBlurTimeoutId);
					this.onElementBlurTimeoutId = 0;
				}
			}
		},

<span id='Cursor-property-onElementBlurTimeoutId'>		/**
</span>		 * @property {Number}
		 * @private
		 * Used in the {@link #onElementBlur} method to capture the pointer to a 50 ms timeout delay on element blur closure
		 */

		onElementBlurTimeoutId : 0,


<span id='Cursor-method-onElementBlur'>		/**
</span>		 * Invokes {@link #fireElementChangeEvent} method on element blur for elements that have an nflcime attribute.
		 * For iframe-based editors, it dispatches a {@link #CursorSaveFocusedEdit} event.
		 *
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] Element firing the event
		 */


		onElementBlur : function(evt) {
			var element = evt.target;
			if (!element)
				return;
			if (element.hasAttribute &amp;&amp; element.hasAttribute(&#39;nflcime&#39;))
				this.fireElementChangeEvent();
			if (element.nodeType == 9) {
				element = element.body;
			}
			if (element &amp;&amp; element.tagName != &#39;IFRAME&#39;) {
				if (this.focusedEdit &amp;&amp; !this.windowLostFocus) {
					NFLCIME.dispatchEvent({
								type : &#39;CursorSaveFocusedEdit&#39;,
								target : this.focusedEdit
							});
					// don&#39;t notify yet, since a focus event might follow
					// immediately
					if (this.onElementBlurTimeoutId) {
						clearTimeout(this.onElementBlurTimeoutId);
					}
					var closure = this.closures[&#39;onElementBlurNotify&#39;];
					if (!closure) {
						var self = this;
						closure = function() {
							self.onElementBlurNotify()
						};
						this.closures[&#39;onElementBlurNotify&#39;] = closure;
					}
					this.onElementBlurTimeoutId = setTimeout(closure, 50);
				}
			}
		},

<span id='Cursor-method-onElementBlurNotify'>		/**
</span>		 * Invokes the {@link #fireElementChangeEvent} method and dispatches a {@link #FocusChanged} event
		 *
		 */

		onElementBlurNotify : function() {
			this.fireElementChangeEvent();
			var prev = this.focusedEdit;
			this.focusedEdit = null;
			NFLCIME.dispatchEvent({
						type : &#39;FocusChanged&#39;,
						target : this.focusedEdit,
						previousTarget : prev
					});
			this.onElementBlurTimeoutId = 0;
			this.stopCursorCheck();
		},
		
<span id='Cursor-method-onWindowFocus'>		/**
</span>		 * Check to see if the previously focused element regained focus when its window regained focus.
		 * @param {Object} [evt] Event details
		 */

		onWindowFocus : function(evt) {
			
			if (!evt.target.nodeType) {
				if (this.windowLostFocus &amp;&amp; this.focusedEdit) {
					if (!this.focusedEdit.hasFocus
							|| this.focusedEdit.hasFocus()) {
						NFLCIME.dispatchEvent({
									type : &#39;FocusChanged&#39;,
									target : this.focusedEdit,
									previousTarget : null
								});
					} else {
						this.focusedEdit = null;
					}
				}
				this.windowLostFocus = false;
			}
		},
		
<span id='Cursor-method-onWindowBlur'>		/**
</span>		 * Focus is lost if the window containing the focused element loses focus
		 * @param {Object} [evt] Event details
		 */

		onWindowBlur : function(evt) {
			if (!evt.target.nodeType) {
				if (this.focusedEdit
						&amp;&amp; evt.target.document == this.focusedEdit.ownerDocument) {
					NFLCIME.dispatchEvent({
								type : &#39;FocusChanged&#39;,
								target : null,
								previousTarget : this.focusedEdit
							});
				}
				this.windowLostFocus = true;
			}
		},


<span id='Cursor-method-onWindowListen'>		/**
</span>		 * Attach DOM Handlers to a window by invoking the {@link #attachDomHandlers} method.
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] The target window
		 */

		onWindowListen : function(evt) {
			var win = evt.target;
			this.attachDOMHandlers(win);
		},


<span id='Cursor-method-onWindowIgnore'>		/**
</span>		 * Make sure we&#39;re not hanging onto objects from the window being
		 * ignored, sets {@link #previousCursorPosition}
		 * @param {Object} [evt] Event details
		 * @param {Object} [evt.target] The target window
		 */


		onWindowIgnore : function(evt) {
			var win = evt.target;
			var doc = win.doc;
			this.detachDOMHandlers(win);

			// make sure we&#39;re not hanging onto objects from the window being
			// ignored
			if (this.focusedEdit) {
				if (this.focusedEdit.ownerDocument == doc) {
					var prev = this.focusedEdit;
					this.focusedEdit = null;
					NFLCIME.dispatchEvent({
								type : &#39;FocusChanged&#39;,
								target : this.focusedEdit,
								previousTarget : prev
							});
				}
			}
			if (this.previousFocusedEdit) {
				if (this.previousFocusedEdit.ownerDocument == doc) {
					this.previousFocusedEdit = null;
				}
			}
			if (this.previousCursorPosition) {
				switch (this.previousCursorPosition.type) {
					case &#39;ie range&#39; :
						var parent = this.previousCursorPosition.data
								.parentElement();
						if (!parent || parent.ownerDocument == doc) {
							this.previousCursorPosition = null;
						}
						break;
					case &#39;dom selection indices&#39; :
						var parent = this.previousCursorPosition.data.edit;
						if (!parent || parent.ownerDocument == doc) {
							this.previousCursorPosition = null;
						}
						break;
					case &#39;dom range&#39; :
						var parent = this.previousCursorPosition.data.commonAncestorContainer;
						if (!parent || parent.ownerDocument == doc) {
							this.previousCursorPosition = null;
						}
						break;
				}

			}
		},
		

<span id='Cursor-method-onKeyDown'>		/**
</span>		 * See if the cursor has moved by calling the {@link #scheduleCursorCheck} method
		 * @param {Object} [evt] Event details
		 */

		onKeyDown : function(evt) {
			this.scheduleCursorCheck();
		},


		
<span id='Cursor-method-onMouseDown'>		/**
</span>		 * Attach {@link #onMouseMove} method to a mousedown event and
		 * see if the cursor has moved by calling the {@link #scheduleCursorCheck} method
		 * @param {Object} [evt] Event details
		 */
		
		onMouseDown : function(evt) {
			var target = evt.target;
			var doc = (target.nodeType == 1) ? target.ownerDocument : target;
			this.attachDOMHandler(doc, &#39;mousedown&#39;, &#39;onMouseMove&#39;);
			this.scheduleCursorCheck(false);
		},
		onMouseUp : function() {
			this.detachDOMHandler(doc, &#39;mousedown&#39;, &#39;onMouseMove&#39;);
		},
		onMouseMove : function() {
			this.checkCursorPosition(false);
		},
		// --- Private functions
		// Add handlers for activate and deactivate event so the focus can be
		// tracked
		attachDOMHandlers : function(win) {
			var doc = win.document;
			this.attachDOMHandler(doc, &#39;keydown&#39;, &#39;onKeyDown&#39;);
			this.attachDOMHandler(doc, &#39;mousedown&#39;, &#39;onMouseDown&#39;);
			this.attachDOMHandler(doc, &#39;mouseup&#39;, &#39;onMouseDown&#39;);
			switch (this.browser) {
				case &#39;ie&#39; :
					this.attachDOMHandler(doc, &#39;focusin&#39;, &#39;onElementFocus&#39;);
					this.attachDOMHandler(doc, &#39;focusout&#39;, &#39;onElementBlur&#39;);
					break;
				case &#39;firefox&#39; :
					this.attachDOMHandler(doc, &#39;focus&#39;, &#39;onElementFocus&#39;, true);
					this.attachDOMHandler(doc, &#39;blur&#39;, &#39;onElementBlur&#39;, true);
					this.attachDOMHandler(win, &#39;focus&#39;, &#39;onWindowFocus&#39;);
					this.attachDOMHandler(win, &#39;blur&#39;, &#39;onWindowBlur&#39;);
					break;
				case &#39;safari&#39; :
					this.attachDOMHandler(doc, &#39;DOMFocusIn&#39;, &#39;onElementFocus&#39;);
					this.attachDOMHandler(doc, &#39;DOMFocusOut&#39;, &#39;onElementBlur&#39;);
					this.attachDOMHandler(win, &#39;focus&#39;, &#39;onWindowFocus&#39;);
					this.attachDOMHandler(win, &#39;blur&#39;, &#39;onWindowBlur&#39;);
					break;
			}
		},
		detachDOMHandlers : function(win) {
			var doc = win.document;
			this.attachDOMHandler(doc, &#39;keydown&#39;, &#39;onKeyDown&#39;);
			this.attachDOMHandler(doc, &#39;mousedown&#39;, &#39;onMouseDown&#39;);
			this.attachDOMHandler(doc, &#39;mouseup&#39;, &#39;onMouseDown&#39;);
			this.attachDOMHandler(doc, &#39;mousemove&#39;, &#39;onMouseMove&#39;);
			switch (this.browser) {
				case &#39;ie&#39; :
					this.detachDOMHandler(doc, &#39;focusin&#39;, &#39;onElementFocus&#39;);
					this.detachDOMHandler(doc, &#39;focusout&#39;, &#39;onElementBlur&#39;);
					break;
				case &#39;firefox&#39; :
					this.detachDOMHandler(doc, &#39;focus&#39;, &#39;onElementFocus&#39;, true);
					this.detachDOMHandler(doc, &#39;blur&#39;, &#39;onElementBlur&#39;, true);
					this.detachDOMHandler(win, &#39;focus&#39;, &#39;onWindowFocus&#39;);
					this.detachDOMHandler(win, &#39;blur&#39;, &#39;onWindowBlur&#39;);
					break;
				case &#39;safari&#39; :
					this.detachDOMHandler(doc, &#39;DOMFocusIn&#39;, &#39;onElementFocus&#39;);
					this.detachDOMHandler(doc, &#39;DOMFocusOut&#39;, &#39;onElementBlur&#39;);
					this.detachDOMHandler(win, &#39;focus&#39;, &#39;onWindowFocus&#39;);
					this.detachDOMHandler(win, &#39;blur&#39;, &#39;onWindowBlur&#39;);
					break;
			}
		},
		// Attach a closure to a DOM element that sends the events to the named
		// handler
		attachDOMHandler : function(element, eventName, handlerName, capturing) {
			var handler = this[handlerName];
			var closure = this.closures[handlerName];
			if (!closure) {
				var self = this;
				switch (this.browser) {
					case &#39;ie&#39; :
						closure = function(evt) {
							if (!evt.target) {
								evt.target = evt.srcElement;
							}
							evt.returnValue = handler.call(self, evt);
						}
						break;
					case &#39;firefox&#39; :
					case &#39;safari&#39; :
						closure = function(evt) {
							var result = handler.call(self, evt);
							if (result != undefined &amp;&amp; result == false) {
								evt.preventDefault();
							}
						}
				}
				this.closures[handlerName] = closure;
			}
			switch (this.browser) {
				case &#39;ie&#39; :
					element.attachEvent(&#39;on&#39; + eventName, closure);
					break;
				case &#39;firefox&#39; :
				case &#39;safari&#39; :
					element.addEventListener(eventName, closure, capturing
									? true
									: false);
					break;
			}
		},
		// Detach an earlier attached closure
		detachDOMHandler : function(element, eventName, handlerName, capturing) {
			var closure = this.closures[handlerName];
			if (closure) {
				switch (this.browser) {
					case &#39;ie&#39; :
						element.detachEvent(&#39;on&#39; + eventName, closure);
						break;
					case &#39;firefox&#39; :
					case &#39;safari&#39; :
						element.removeEventListener(eventName, closure,
								capturing ? true : false);
						break;
				}
			}
		},
		// Whether an element is editable
		isEditControl : function(element) {
			if (element.tagName == &#39;TEXTAREA&#39;) {
				return !element.disabled;
			} else if (element.tagName == &#39;INPUT&#39;
					&amp;&amp; (element.type == &#39;text&#39; || element.type == &#39;file&#39; || element.type == &#39;password&#39;)) {
				return !element.disabled;
			} else if (element.contentEditable == &#39;true&#39;) {
				return !element.disabled;
			} else if (element.ownerDocument
					&amp;&amp; element.ownerDocument.designMode == &#39;on&#39;) {
				return !element.disabled;
			}
			return false;
		},

		
<span id='Cursor-method-moveRangeEnd'>		/**
</span>		 * Move the end-point of a DOM range object
		 * 
		 * 
		 */
		moveRangeEnd : function(container, range, amount) {
			if (amount == 0) {
				return;
			}
			var result = (amount &lt; 0) ? this.findIndexBehind(container,
					range.endContainer, range.endOffset, -amount, true) : this
					.findIndexAhead(container, range.endContainer,
							range.endOffset, amount, true);
			range.setEnd(result.node, result.index);
		},
		
<span id='Cursor-method-moveRangeStart'>		/**
</span>		 * Move the starting-point of a DOM range object
		 * 
		 * 
		 */
		 
		moveRangeStart : function(container, range, amount) {
			if (amount == 0) {
				return;
			}
			var result = (amount &lt; 0)
					? this.findIndexBehind(container, range.startContainer,
							range.startOffset, -amount, true)
					: this.findIndexAhead(container, range.startContainer,
							range.startOffset, amount, true);
			range.setStart(result.node, result.index);
		},
		// Find a text node and index at a given distance ahead of the given
		// node and index
		findIndexAhead : function(container, node, index, amount, canScanUp) {
			var result = {
				node : node,
				index : index,
				amount : 0
			};
			if (node.nodeType == 3) {
				var text = node.nodeValue;
				result.index = Math.min(text.length, index + amount);
				result.amount = result.index - index;
			} else {
				var amount_found = 0;
				for (var c = node.childNodes[index]; c; c = c.nextSibling) {
					result = this.findIndexAhead(container, c, 0, amount
									- amount_found, false);
					amount_found += result.amount;
					result.amount = amount_found;
					if (amount_found == amount) {
						break;
					}
				}
			}
			if (result.amount &lt; amount) {
				// don&#39;t go pass the container
				if (node != container &amp;&amp; canScanUp) {
					// scan parent node, starting from the next node
					var node_index = this.findNodeIndex(node);
					var new_result = this.findIndexAhead(container,
							node.parentNode, node_index + 1, amount
									- result.amount, true);
					new_result.amount += result.amount;
					result = new_result;
				}
			}
			return result;
		},
		// Find a text node and index at a given distance behind the given node
		// and index
		findIndexBehind : function(container, node, index, amount, canScanUp) {
			var result = {
				node : node,
				index : index,
				amount : 0
			};
			if (node.nodeType == 3) {
				result.index = Math.max(0, index - amount);
				result.amount = index - result.index;
			} else {
				if (index &gt; 0) {
					var amount_found = 0;
					for (var c = node.childNodes[index - 1]; c; c = c.previousSibling) {
						var end_index;
						if (c.nodeType == 3) {
							end_index = c.nodeValue.length;
						} else {
							end_index = c.childNodes.length;
						}
						result = this.findIndexBehind(container, c, end_index,
								amount - amount_found, false);
						amount_found += result.amount;
						result.amount = amount_found;
						if (amount_found == amount) {
							break;
						}
					}
				}
			}
			if (result.amount &lt; amount) {
				// don&#39;t go pass the container
				if (node != container &amp;&amp; canScanUp) {
					// scan parent node, starting from the previous node
					var node_index = this.findNodeIndex(node);
					var new_result = this.findIndexBehind(container,
							node.parentNode, node_index,
							amount - result.amount, true);
					new_result.amount += result.amount;
					result = new_result;
				}
			}
			return result;
		},
		// Calculate new indices after neighboring textnodes are fused during
		// normalization
		findNormalizedPosition : function(node, index) {
			var text_index = index;
			var first_text_node = node;
			for (var c = node.previousSibling; c; c = c.previousSibling) {
				if (c.nodeType == 3) {
					text_index += c.nodeValue.length;
					first_text_node = c;
				} else {
					break;
				}
			}
			var node_index = this.findNodeIndex(first_text_node);
			return {
				nodeIndex : node_index,
				textIndex : text_index
			};
		},
		// Find the index of a node
		findNodeIndex : function(node) {
			for (var i = 0, c = node.parentNode.firstChild; c; i++, c = c.nextSibling) {
				if (c == node) {
					return i;
				}
			}
		},
		scheduleCursorCheck : function(continuous) {
			if (continuous) {
				if (!this.cursorCheckIntervalID) {
					var closure = this.closures[&#39;checkCursorPositionInterval&#39;];
					if (!closure) {
						var self = this;
						var closure = function() {
							self.checkCursorPosition();
						}
						this.closures[&#39;checkCursorPositionInterval&#39;] = closure;
					}
					this.cursorCheckIntervalID = setInterval(closure, 100);
				}
			} else {
				if (!this.cursorCheckTimeoutID) {
					var closure = this.closures[&#39;checkCursorPositionTimeout&#39;];
					if (!closure) {
						var self = this;
						var closure = function() {
							self.checkCursorPosition();
							self.cursorCheckTimeoutID = 0;
						}
						this.closures[&#39;checkCursorPositionTimeout&#39;] = closure;
					}
					this.cursorCheckTimeoutID = setTimeout(closure, 0);
				}
			}
		},
		stopCursorCheck : function() {
			if (this.cursorCheckTimeoutID) {
				clearTimeout(this.cursorCheckTimeoutID);
				this.cursorCheckIntervalID = 0;
			}
			if (this.cursorCheckIntervalID) {
				clearInterval(this.cursorCheckIntervalID);
				this.cursorCheckIntervalID = 0;
			}
		},
		checkCursorPosition : function() {
				
			if (this.focusedEdit &amp;&amp; !this.windowLostFocus) {
				var new_pos = this.getCursorPosition(this.focusedEdit);
				var old_pos = this.previousCursorPosition;
				if (!this.compareCursorPosition(new_pos, old_pos)) {
					if (old_pos) {
						NFLCIME.dispatchEvent({
									type : &#39;CursorMoved&#39;,
									target : this.focusedEdit
								});
						this.disposeCursorPosition(old_pos);
					}
					this.previousCursorPosition = new_pos;
				} else {
					this.disposeCursorPosition(new_pos);
				}
			}
		},
		getCursorPosition : function(edit) {
			try {
				var obj = {};
				switch (this.browser) {
					case &#39;ie&#39; :
						var doc = edit.ownerDocument;
						var range = doc.selection.createRange();
						if (range &amp;&amp; range.duplicate) {
							obj.data = range.duplicate();
							obj.type = &#39;ie range&#39;;
						} else {
							obj.type = &#39;null&#39;;
						}
						break;
					case &#39;firefox&#39; :
					case &#39;safari&#39; :
						if (edit.tagName == &#39;TEXTAREA&#39;
								|| edit.tagName == &#39;INPUT&#39;) {
							obj.data = {
								edit : edit,
								selectionStart : edit.selectionStart,
								selectionEnd : edit.selectionEnd
							};
							obj.type = &#39;dom selection indices&#39;;
						} else {
							var doc = edit.ownerDocument;
							var win = doc.defaultView;
							var selection = win.getSelection();
							if (selection.rangeCount &gt; 0) {
								var range = selection.getRangeAt(0);
								obj.data = range.cloneRange();
								obj.type = &#39;dom range&#39;;
							} else {
								obj.type = &#39;null&#39;;
							}
						}
						break;
				}
				return obj;
			} catch (e) {
				return null;
			}
		},
		compareCursorPosition : function(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a.type != b.type) {
				return false;
			}
			switch (a.type) {
				case &#39;ie range&#39; :
					return a.data.isEqual(b.data);
				case &#39;dom selection indices&#39; :
					return (a.data.edit == b.data.edit
							&amp;&amp; a.data.selectionStart == b.data.selectionStart &amp;&amp; a.data.selectionEnd == b.data.selectionEnd);
				case &#39;dom range&#39; :
					// need the try block in case a and b are in different block
					try {
						return ((a.data.compareBoundaryPoints(Range.END_TO_END,
								b.data) == 0) &amp;&amp; (a.data.compareBoundaryPoints(
								Range.START_TO_START, b.data) == 0));
					} catch (e) {
						return false;
					}
			}
		},
		disposeCursorPosition : function(p) {
			if (p) {
				switch (p.type) {
					case &#39;dom range&#39; :
						p.data.detach();
				}
			}
		},
		initialize : function(env) {
			this.browser = env.browser;
			this.closures = {};
			NFLCIME.addEventListener(&#39;ModuleActivate&#39;, this);
			NFLCIME.addEventListener(&#39;ModuleDeactivate&#39;, this);
		},
		// --- Private variables
		active : false,
		browser : null,
		closures : null,
		focusedEdit : null,
		previousFocusedEdit : null,
		windowLostFocus : false,
		previousCursorPosition : null,
		cursorCheckIntervalID : 0,
		cursorCheckTimeoutID : 0
	}
});</pre>
</body>
</html>
